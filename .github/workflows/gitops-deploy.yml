name: GitOps CI/CD Pipeline

on:
  push:
    branches: [ main, staging, production ]
  pull_request:
    branches: [ main, staging, production ]

env:
  AWS_REGION: ap-southeast-1
  DOCKER_REGISTRY: 0xsaju

permissions:
  contents: read

jobs:
  # Get AWS Account ID
  aws-account:
    runs-on: ubuntu-latest
    outputs:
      account: ${{ steps.account.outputs.account }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get AWS Account ID
        id: account
        run: |
          echo "account=$(aws sts get-caller-identity --query Account --output text)" >> $GITHUB_OUTPUT

  # Build and Push Images
  build-and-push:
    needs: aws-account
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [user-service, product-service, order-service, frontend]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Determine environment and tag
        id: env
        run: |
          if [[ ${{ github.ref }} == 'refs/heads/staging' ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "docker_tag=staging" >> $GITHUB_OUTPUT
          elif [[ ${{ github.ref }} == 'refs/heads/production' ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "docker_tag=production" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "docker_tag=staging" >> $GITHUB_OUTPUT
          fi

      - name: Build and push ${{ matrix.service }}
        uses: docker/build-push-action@v5
        with:
          context: ./${{ matrix.service }}
          push: true
          tags: ${{ needs.aws-account.outputs.account }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ matrix.service }}:${{ steps.env.outputs.docker_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

  # Deploy Infrastructure
  deploy-infrastructure:
    needs: [aws-account, build-and-push]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/staging' || github.ref == 'refs/heads/production'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Determine environment
        id: env
        run: |
          if [[ ${{ github.ref }} == 'refs/heads/staging' ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
          elif [[ ${{ github.ref }} == 'refs/heads/production' ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=gitops-learning-terraform-state-1753768527" \
            -backend-config="key=${{ steps.env.outputs.environment }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=terraform-state-lock-new" \
            -backend-config="encrypt=true"

      - name: Terraform Plan
        run: |
          cd terraform
          terraform plan \
            -var-file="environments/${{ steps.env.outputs.environment }}.tfvars" \
            -out="${{ steps.env.outputs.environment }}.plan"

      - name: Terraform Apply
        run: |
          cd terraform
          terraform apply "${{ steps.env.outputs.environment }}.plan"

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ steps.env.outputs.environment }}-cluster

      - name: Install ArgoCD
        run: |
          # Check if ArgoCD is already installed
          if kubectl get namespace argocd >/dev/null 2>&1; then
            echo "ArgoCD namespace exists, checking if ArgoCD is running..."
            if kubectl get pods -n argocd -l app.kubernetes.io/name=argocd-server --no-headers | grep -q Running; then
              echo "ArgoCD is already running, skipping installation"
            else
              echo "ArgoCD namespace exists but not running, reinstalling..."
              # Add ArgoCD Helm repository
              helm repo add argo https://argoproj.github.io/argo-helm
              helm repo update
              
              # Install ArgoCD
              helm upgrade --install argocd argo/argocd \
                --namespace argocd \
                --create-namespace \
                --values argocd/values.yaml \
                --set server.ingress.hosts[0]=argocd.${{ steps.env.outputs.environment }}.example.com \
                --wait
            fi
          else
            echo "Installing ArgoCD for the first time..."
            # Add ArgoCD Helm repository
            helm repo add argo https://argoproj.github.io/argo-helm
            helm repo update
            
            # Install ArgoCD
            helm upgrade --install argocd argo/argocd \
              --namespace argocd \
              --create-namespace \
              --values argocd/values.yaml \
              --set server.ingress.hosts[0]=argocd.${{ steps.env.outputs.environment }}.example.com \
              --wait
          fi

      - name: Wait for ArgoCD to be ready
        run: |
          # Check if ArgoCD pods are already ready
          if kubectl get pods -n argocd -l app.kubernetes.io/name=argocd-server --no-headers | grep -q Running; then
            echo "ArgoCD is already running and ready"
          else
            echo "Waiting for ArgoCD to be ready..."
            kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s
          fi

      - name: Apply App-of-Apps
        run: |
          kubectl apply -f argocd/app-of-apps.yaml

  # Sync ArgoCD Applications
  sync-argocd:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/staging' || github.ref == 'refs/heads/production'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Determine environment
        id: env
        run: |
          if [[ ${{ github.ref }} == 'refs/heads/staging' ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
          elif [[ ${{ github.ref }} == 'refs/heads/production' ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          fi

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ steps.env.outputs.environment }}-cluster

      - name: Get ArgoCD admin password
        run: |
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "ARGOCD_PASSWORD=$ARGOCD_PASSWORD" >> $GITHUB_ENV

      - name: Get ArgoCD ALB DNS
        run: |
          # Get the ALB DNS name
          ALB_DNS=$(kubectl get ingress argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "ARGOCD_ALB_DNS=$ALB_DNS" >> $GITHUB_ENV
          echo "ArgoCD ALB DNS: $ALB_DNS"

      - name: Install ArgoCD CLI
        run: |
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
          rm argocd-linux-amd64

      - name: Sync ArgoCD applications
        run: |
          # Wait for ArgoCD to be ready
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s
          
          # Get ALB DNS
          ALB_DNS=$(kubectl get ingress argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          
          # Login to ArgoCD
          argocd login $ALB_DNS --username admin --password $ARGOCD_PASSWORD --insecure
          
          # Sync all applications
          argocd app sync app-of-apps
          
          # Wait for sync to complete
          argocd app wait app-of-apps

  # Health Check
  health-check:
    needs: sync-argocd
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/staging' || github.ref == 'refs/heads/production'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Determine environment
        id: env
        run: |
          if [[ ${{ github.ref }} == 'refs/heads/staging' ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
          elif [[ ${{ github.ref }} == 'refs/heads/production' ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          fi

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ steps.env.outputs.environment }}-cluster

      - name: Wait for applications to be ready
        run: |
          # Wait for all deployments to be ready
          kubectl wait --for=condition=available deployment --all --all-namespaces --timeout=600s
          
          # Check application health
          kubectl get pods --all-namespaces
          kubectl get services --all-namespaces

      - name: Test application endpoints
        run: |
          # Get the ALB endpoint
          ALB_ENDPOINT=$(kubectl get ingress -n frontend frontend-ingress -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          
          # Test frontend
          curl -f http://$ALB_ENDPOINT/ || exit 1
          
          # Test user service
          USER_SERVICE_IP=$(kubectl get service user-service -n user-service -o jsonpath='{.spec.clusterIP}')
          kubectl run test-curl --image=curlimages/curl -i --rm --restart=Never -- curl -f http://$USER_SERVICE_IP:5001/health || exit 1

      - name: Get ArgoCD ALB DNS
        run: |
          # Get the ArgoCD ALB DNS name
          ARGOCD_ALB_DNS=$(kubectl get ingress argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "ARGOCD_ALB_DNS=$ARGOCD_ALB_DNS" >> $GITHUB_ENV

      - name: Notify deployment success
        run: |
          echo "ðŸŽ‰ ${{ steps.env.outputs.environment }} deployment successful!"
          echo "ArgoCD URL: https://$ARGOCD_ALB_DNS"
          echo "Application URL: http://$ALB_ENDPOINT" 